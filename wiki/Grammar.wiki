#summary The Grammar Rules defining the syntactical structure of Antelope programs

= Table of Contents =
 * == [Grammar#The_Grammar The Grammar] ==
 * == [Grammar#Syntax_Tree_Classes Syntax Tree Classes] ==
 * == [Grammar#Example_Walkthrough Example Walkthrough] ==
 * == [Grammar#Order_of_Operations Order of Operations] ==

<br>
----
= The Grammar =
----
<br>
*The Antelope language grammar* is a deterministic specification of Antelope syntax. Each grammar rule describes a portion of source code that the compiler can [http://en.wikipedia.org/wiki/Parsing parse] into an [Grammar#Syntax_Tree_Classes abstract representation] that the compiler can analyze and manipulate directly.

_For a less technical summary of Antelope, see the [http://code.google.com/p/antelope/wiki/Overview Overview page]._

==== Conventions Used: ====
||<font face="arial black" color="#AAAAFF">|</font>||Separates alternate options ("OR")||Sub<font face="arial black" color="#AAAAFF">,,1,,</font>Scripts<font face="arial black" color="#AAAAFF">,,2,,</font>||Used for reference in distinguishing similar items||
||<font face="arial black" color="#AAAAFF">[ ]</font>||Optional items (these items can be omitted)||_Italic text_||Only a _description_ of valid syntax||
||<font face="arial black" color="#AAAAFF">( )</font>||Grouping of items (treat these items as one unit)||`ALL` `CAPS`||Represents anything from the corresponding rule-name||
||<font face="arial black" color="#AAAAFF">`*`</font>||The preceding item is repeated *zero or more* times||_`ITALIC` `CAPS`_||Partial rules separated from larger rules to save space||
||<font face="arial black" color="#AAAAFF">+</font>||The preceding item is repeated *one or more* times||<font face="arial black" color="#AAAAFF">,</font><font face="arial black" color="#AAAAFF">,</font>||List of *one or more* items, separated with commas||
||||||||`(Everything else is actual language syntax which can be typed as shown)`||

==== Grammar Rules: ====
||<font face="arial black">Rule</font>||<font face="arial black">Grammar</font>||<font face="arial black">Notes / <font color="red">Additional Semantics</font></font> ||
||||||<font face="arial black"> - - Preprocessor Rules - - </font><font color="#888888">_These rules are processed (and removed) before any other rules are applied._</font>||
||`COMMENT`||<font face="arial black" color="#AAAAFF">(</font> `//` <font face="arial black" color="#AAAAFF">(</font>_`NonLineBreak`_<font face="arial black" color="#AAAAFF">)`*`</font> _`LineBreak`_ <font face="arial black" color="#AAAAFF">) | (</font> `/*` <font face="arial black" color="#AAAAFF">(</font>_`NonStarSlash`_<font face="arial black" color="#AAAAFF">)`*`</font> `*/` <font face="arial black" color="#AAAAFF">)</font>||Comments may be intermixed, and are removed/ignored as they are found.||
||`PP_INC`||`#include` `STRING`||Include source code from another file or url.||
||`PP_DEF`||`#define` `IDENT`<font face="arial black" color="#AAAAFF">,</font><font face="arial black" color="#AAAAFF">,</font>||Define an identifier (as a "flag" for `PP_IF`).||
||`PP_IF`||`#if` _`PP_OR`_<font face="arial black" color="#AAAAFF">,,1,,</font> _`CODE`_ <font face="arial black" color="#AAAAFF">[</font>`#elif` _`PP_OR`_<font face="arial black" color="#AAAAFF">,,2,,</font> _`CODE`_ <font face="arial black" color="#AAAAFF">[</font>`#else` _`SRC`_<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">]</font> `#endif`||Designate code to be used on conditions based on `#define`d values.||
||> _`PP_OR`_||_`PP_AND`_<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `|``|` _`PP_AND`_<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||Conditional-"OR" for `PP_IF`.||
||> _`PP_AND`_||_`PP_VAL`_<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `&``&` _`PP_VAL`_<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||Conditional-"AND" for `PP_IF`.||
||> _`PP_VAL`_||<font face="arial black" color="#AAAAFF">[</font> `!` <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">(</font> `IDENT` <font face="arial black" color="#AAAAFF">|</font> `(` _`PP_OR`_ `)` <font face="arial black" color="#AAAAFF">)</font>||Preprocessor value for `PP_IF`.||
||> _`CODE`_||_Any amount of source code, including other preprocessor directives_||Source code.||
||`PP_ERR`||`#error` `STRING`||Generate a compile-time error message.||
||`PP_ASM`||`#assembly` <font face="arial black" color="#AAAAFF">(</font> `EXPR` <font face="arial black" color="#AAAAFF">)+</font>||Insert assembly code at the head of the program.||
||`PP_ALLOC`||`#allocate` `STRING` <font face="arial black" color="#AAAAFF">[</font> `EXPR` <font face="arial black" color="#AAAAFF">]</font>||Designate a "Safe-RAM" Allocation (used for static initializations).||
||||||<font face="arial black"> - - Top-Level Rules - - </font><font color="#888888">_The top level after preprocessing is done._</font>||
||`SOURCE`||<font face="arial black" color="#AAAAFF">[</font> `NAMESPACE` <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">(</font> `USING` <font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">(</font> `INIT` <font face="arial black" color="#AAAAFF">|</font> _`ADT`_ <font face="arial black" color="#AAAAFF">|</font> `FUNC` <font face="arial black" color="#AAAAFF">|</font> <font face="arial black" color="#AAAAFF">[</font>`VARDEC`<font face="arial black" color="#AAAAFF">|</font>`CONST`<font face="arial black" color="#AAAAFF">]</font> `;`  <font face="arial black" color="#AAAAFF">)`*`</font>||The top-level of program source code.||
||`NAMESPACE`||`namespace` <font face="arial black" color="#AAAAFF">(</font> `P_ID` `.` <font face="arial black" color="#AAAAFF">)`*`</font> `P_DT` `;`||Namespace declaration.||
||`USING`||`using` <font face="arial black" color="#AAAAFF">[</font> `IDENT` `=` <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">(</font> `P_ID` `.` <font face="arial black" color="#AAAAFF">)`*`</font> `P_ID` `;`||Namespace-"Using"/Aliasing.||
||`INIT`||<font face="arial black" color="#AAAAFF">[</font> `$` <font face="arial black" color="#AAAAFF">]</font> `init` `{` <font face="arial black" color="#AAAAFF">(</font> `STATEMENT`<font face="arial black" color="#AAAAFF">)`*`</font> `}`||Static Initialization Block (happens "before" main). The `$` requires it to be "interpreted".||
||> _`ADT`_||`ENUM` <font face="arial black" color="#AAAAFF">|</font> `TYPEDEF` <font face="arial black" color="#AAAAFF">|</font> `SW_VAR` <font face="arial black" color="#AAAAFF">|</font> `IFACE` <font face="arial black" color="#AAAAFF">|</font> `STRUCT` <font face="arial black" color="#AAAAFF">|</font> `COFUNC`||Abstract Data-Type Declarations.||
||`ENUM`||`enum` `IDENT`<font face="arial black" color="#AAAAFF">,,1,,</font> `{` <font face="arial black" color="#AAAAFF">(</font> `IDENT`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `}`||Enumeration Type-Declaration.||
||`TYPEDEF`||<font face="arial black" color="#AAAAFF">[</font> `new` <font face="arial black" color="#AAAAFF">]</font> `type` `IDENT` `=` `TYPE` `;`||Type Definition ("`new type`" creates a distinct new type, rather than just an alias).||
||`SW_VAR`||`switch` `{` <font face="arial black" color="#AAAAFF">(</font> `IDENT`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `}` `IDENT`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">[</font> `=` `EXPR` <font face="arial black" color="#AAAAFF">]</font> `;`||Switch-Variable Declaration.||
||`IFACE`||`iface` `P_DT` `{` <font face="arial black" color="#AAAAFF">(</font> `VARDEC` `;` <font face="arial black" color="#AAAAFF">|</font> `V_FUNC` <font face="arial black" color="#AAAAFF">)`*`</font> `}`||Interface Type-Declaration.||
||`STRUCT`||`struct` `P_DT` `{` <font face="arial black" color="#AAAAFF">(</font> _`MEMBER`_ <font face="arial black" color="#AAAAFF">)`*`</font> `}`||Structure Type-Declaration.||
||`COFUNC`||`cofunc` <font face="arial black" color="#AAAAFF">[</font> `$` <font face="arial black" color="#AAAAFF">]</font> `P_DT` <font face="arial black" color="#AAAAFF">[</font>`{` <font face="arial black" color="#AAAAFF">(</font> _`MEMBER`_ <font face="arial black" color="#AAAAFF">)`*`</font> `}`<font face="arial black" color="#AAAAFF">]</font> _`F_BODY`_||Cofunction Type-Declaration. The `$` designates that the underlying function is "inline".||
||> _`MEMBER`_||`VARDEC` `;` <font face="arial black" color="#AAAAFF">|</font> `CTOR` <font face="arial black" color="#AAAAFF">|</font> `V_FUNC` <font face="arial black" color="#AAAAFF">|</font> `COFUNC`||Data Member of a `STRUCT` or `COFUNC`.||
||`CTOR`||`new` _`F_BODY`_ <font face="arial black" color="#AAAAFF">|</font><br>`delete` <font face="arial black" color="#AAAAFF">(</font> `{` <font face="arial black" color="#AAAAFF">(</font>`STATEMENT`<font face="arial black" color="#AAAAFF">)`*`</font> `}` <font face="arial black" color="#AAAAFF">|</font> `=>` `COMMAND` `;` <font face="arial black" color="#AAAAFF">|</font> `@` `EXPR` `;` <font face="arial black" color="#AAAAFF">)</font>||Constructor (`new`) /<br>Destructor (`delete`).||
||`FUNC`||`func` <font face="arial black" color="#AAAAFF">[</font> `$` <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">(</font>`P_ID` `.`<font face="arial black" color="#AAAAFF">)`*`</font> `P_DT` _`F_BODY`_||Function Declaration. The `$` designates that the function is "inline".||
||> _`F_BODY`_||<font face="arial black" color="#AAAAFF">[</font> _`ARGS`_<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">]</font> `@` `EXPR` `;` <font face="arial black" color="#AAAAFF">|</font> _`ARGS`_<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">(</font> `{` <font face="arial black" color="#AAAAFF">(</font>`STATEMENT`<font face="arial black" color="#AAAAFF">)`*`</font> `}` <font face="arial black" color="#AAAAFF">|</font> `=>` `COMMAND` `;` <font face="arial black" color="#AAAAFF">)</font>||Function Body (including arguments and return values).||
||> _`ARGS`_||`(` <font face="arial black" color="#AAAAFF">[</font> <font face="arial black" color="#AAAAFF">(</font> _`VARDEC`_ <font face="arial black" color="#AAAAFF">|</font> `@` <font face="arial black" color="#AAAAFF">(</font>`P_ID` `.`<font face="arial black" color="#AAAAFF">)`*`</font> `P_ID` <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> <font face="arial black" color="#AAAAFF">]</font> `)` _`RETURNS`_||Function Arguments with optional return type(s).||
||> _`RETURNS`_||<font face="arial black" color="#AAAAFF">[</font> `:` `TYPE`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">|</font> `:` `(` <font face="arial black" color="#AAAAFF">(</font> `TYPE`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `)` <font face="arial black" color="#AAAAFF">]</font>||The optional return type(s) of a function.||
||`V_FUNC`||`func` `IDENT` <font face="arial black" color="#AAAAFF">(</font> _`F_BODY`_ <font face="arial black" color="#AAAAFF">|</font> _`T_ARGS`_ `;` <font face="arial black" color="#AAAAFF">)</font>||Virtual Function Declaration.||
||`TYPE`||<font face="arial black" color="#AAAAFF">[</font>`static`<font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font>`const`<font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font>`volatile`<font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font> `&` <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font>`[` `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `,` `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font> `]`<font face="arial black" color="#AAAAFF">]</font><br><font face="arial black" color="#AAAAFF">(</font> `*` <font face="arial black" color="#AAAAFF">|</font> `[` <font face="arial black" color="#AAAAFF">(</font> `,` `EXPR`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">)`*`</font> `]` <font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">(</font>`P_ID` `.`<font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">(</font> `P_ID` <font face="arial black" color="#AAAAFF">|</font> `func` _`T_ARGS`_ <font face="arial black" color="#AAAAFF">)</font>||A Data-Type (Modifiers, Reference, Sized-Array, Array/Pointer, Context, Base-Type).||
||> _`T_ARGS`_||`(` <font face="arial black" color="#AAAAFF">[</font> `TYPE`<font face="arial black" color="#AAAAFF">,</font><font face="arial black" color="#AAAAFF">,</font> <font face="arial black" color="#AAAAFF">|</font> `VARDEC`<font face="arial black" color="#AAAAFF">,</font><font face="arial black" color="#AAAAFF">,</font> <font face="arial black" color="#AAAAFF">]</font> `)` _`RETURNS`_||Named or "Types only" Function Arguments with optional return type(s).||
||||||<font face="arial black"> - - Statement-Level Rules - -</font>||
||`STATEMENT`||`CONSTRUCT` <font face="arial black" color="#AAAAFF">|</font> `LABEL` <font face="arial black" color="#AAAAFF">|</font> <font face="arial black" color="#AAAAFF">[</font> `COMMAND` <font face="arial black" color="#AAAAFF">]</font> `;`||Valid "whole pieces" of code.||
||`CONSTRUCT`||<font face="arial black" color="#AAAAFF">[</font> `$` <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">(</font> `IF_ELSE` <font face="arial black" color="#AAAAFF">|</font> `WHILE` <font face="arial black" color="#AAAAFF">|</font> `DO` <font face="arial black" color="#AAAAFF">|</font> `FOR` <font face="arial black" color="#AAAAFF">|</font> `FOREACH` <font face="arial black" color="#AAAAFF">|</font> `SWITCH` <font face="arial black" color="#AAAAFF">)</font>||Flow-Control Constructs. The `$` requires it to be "interpreted".||
||`IF_ELSE`||`if` `(` `EXPR` `)` _`BLOCK`_<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">[</font> `else` _`BLOCK`_<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font>||`IF`(-`ELSE`) Conditional Construct.||
||`WHILE`||_`LOOPCON`_ _`BLOCK`_||`WHILE`/`UNTIL` loop Construct.||
||`DO`||`do` _`BLOCK`_ <font face="arial black" color="#AAAAFF">[</font> _`LOOPCON`_<font face="arial black" color="#AAAAFF">,,1,,</font> `;` <font face="arial black" color="#AAAAFF">]</font><br><font face="arial black" color="#AAAAFF">|</font> `do` `{` <font face="arial black" color="#AAAAFF">(</font> `STATEMENT`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">)`*`</font> `=>` _`LOOPCON`_<font face="arial black" color="#AAAAFF">,,2,,</font> `;` <font face="arial black" color="#AAAAFF">(</font> `STATEMENT`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font> `}`||`DO`(-`WHILE`/-`UNTIL`) loop Construct.||
||> _`LOOPCON`_||<font face="arial black" color="#AAAAFF">(</font> `while` <font face="arial black" color="#AAAAFF">|</font> `until` <font face="arial black" color="#AAAAFF">)</font> `(` `EXPR` `)`||Looping Condition for "Do"- and "While"-loops.||
||`FOR`||`for` `(` <font face="arial black" color="#AAAAFF">(</font> <font face="arial black" color="#AAAAFF">[</font> `COMMAND`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">]</font> `;` <font face="arial black" color="#AAAAFF">[</font> `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">]</font> `;` <font face="arial black" color="#AAAAFF">[</font> `COMMAND`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font> `)` _`BLOCK`_||`FOR` loop Construct.||
||`FOREACH`||`for` `(` _`EACH_IN`_ `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">[</font> `,` `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">[</font> `,` `EXPR`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">)</font> `)` _`BLOCK`_||`FOR-EACH` loop Construct.||
||> _`EACH_IN`_||_`A_VAR`_<font face="arial black" color="#AAAAFF">,,1,,</font> `:` <font face="arial black" color="#AAAAFF">|</font> `UNARY`<font face="arial black" color="#AAAAFF">,,1,,</font> `:=` <font face="arial black" color="#AAAAFF">|</font> `(` <font face="arial black" color="#AAAAFF">[</font> _`A_VAR`_<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">],</font><font face="arial black" color="#AAAAFF">,</font> `)` `:` <font face="arial black" color="#AAAAFF">|</font> `(` <font face="arial black" color="#AAAAFF">(</font> `UNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `)` `:=`||The "each `_` in" variable(s) for a "For-Each" Loop.||
||> _`A_VAR`_||`UNARY` <font face="arial black" color="#AAAAFF">|</font> `TYPE` `IDENT` <font face="arial black" color="#AAAAFF">[</font> `@` `EXPR` <font face="arial black" color="#AAAAFF">]||A single (new or existing) Variable.||
||`SWITCH`||`switch` `(` `EXPR` `)` _`BLOCK`_||`SWITCH`-`CASE` Construct.||
||> _`BLOCK`_||`{` <font face="arial black" color="#AAAAFF">(</font> `STATEMENT` <font face="arial black" color="#AAAAFF">)`*`</font> `}` <font face="arial black" color="#AAAAFF">|</font> `STATEMENT`<font face="arial black" color="#AAAAFF">,,3,,</font>||A Block of code, or a single statement.||
||`LABEL`||<font face="arial black" color="#AAAAFF">(</font> `case` <font face="arial black" color="#AAAAFF">(</font> `IDENT`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> <font face="arial black" color="#AAAAFF">|</font> `default` <font face="arial black" color="#AAAAFF">|</font> `IDENT`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)</font> `:`||Label a line of code for use with `break`, `continue`, or `goto`.||
||`COMMAND`||`BRANCH` <font face="arial black" color="#AAAAFF">|</font> `DELETE` <font face="arial black" color="#AAAAFF">|</font> `ASM` <font face="arial black" color="#AAAAFF">|</font> `CONST` <font face="arial black" color="#AAAAFF">|</font> `VARDEC` <font face="arial black" color="#AAAAFF">|</font> `ASSIGN`||Non-Construct Statements.||
||`BRANCH`||<font face="arial black" color="#AAAAFF">(</font> `return` <font face="arial black" color="#AAAAFF">|</font> `yield` <font face="arial black" color="#AAAAFF">|</font> `break` <font face="arial black" color="#AAAAFF">|</font> `continue` <font face="arial black" color="#AAAAFF">)</font> <font face="arial black" color="#AAAAFF">[</font> `EXPR` <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">|</font> `goto` `IDENT`||Branching statements.||
||`DELETE`||`delete` `UNARY`||Reclaim memory from specified variable / address.||
||`ASM`||`assembly` <font face="arial black" color="#AAAAFF">(</font> `EXPR` <font face="arial black" color="#AAAAFF">)+</font>||Inline Assembly code. String-literals are embedded as is; all else is computed beforehand.||
||`CONST`||`const` <font face="arial black" color="#AAAAFF">(</font> `IDENT` `=` `EXPR` <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font>||Constant Declaration (constant expressions).||
||`VARDEC`||`TYPE` <font face="arial black" color="#AAAAFF">(</font> `IDENT`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">[</font> _`V_INIT`_ <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font> `@` `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font> `=` `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font><br><font face="arial black" color="#AAAAFF">|</font> <font face="arial black" color="#AAAAFF">(</font> `IDENT`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">|</font> `(` <font face="arial black" color="#AAAAFF">(</font> `IDENT`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `)` <font face="arial black" color="#AAAAFF">)</font> `:=` `EXPR`<font face="arial black" color="#AAAAFF">,,3,,</font>||Variable Declaration: (`datatype varName @ assemblyAddress = initValue`).||
||> _`V_INIT`_||`(` <font face="arial black" color="#AAAAFF">[</font> `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">,</font><font face="arial black" color="#AAAAFF">,</font> <font face="arial black" color="#AAAAFF">]</font> `)` <font face="arial black" color="#AAAAFF">[</font>`{` <font face="arial black" color="#AAAAFF">[</font> <font face="arial black" color="#AAAAFF">(</font> `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font> `=` `EXPR`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> <font face="arial black" color="#AAAAFF">]</font> `}`<font face="arial black" color="#AAAAFF">]</font>||Initialize a Variable via constructor call and initialization list.||
||`ASSIGN`||<font face="arial black" color="#AAAAFF">(</font> `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> _`ASN_OP`_ <font face="arial black" color="#AAAAFF">)`*`</font> `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font>||(`L◄-R`) Assignment (resolves right to left).||
||> _`ASN_OP`_||`=` <font face="arial black" color="#AAAAFF">|</font> `*=` <font face="arial black" color="#AAAAFF">|</font> `/=` <font face="arial black" color="#AAAAFF">|</font> `%=` <font face="arial black" color="#AAAAFF">|</font> `+=` <font face="arial black" color="#AAAAFF">|</font> `-=` <font face="arial black" color="#AAAAFF">|</font> `<<=` <font face="arial black" color="#AAAAFF">|</font> `>>=` <font face="arial black" color="#AAAAFF">|</font> `<<<=` <font face="arial black" color="#AAAAFF">|</font> `>>>=` <font face="arial black" color="#AAAAFF">|</font> `&=` <font face="arial black" color="#AAAAFF">|</font> `^=` <font face="arial black" color="#AAAAFF">|</font> `|=`||Assignment Operators (e.g. "`A` `+=` `B`" is shorthand for "`A` `=` `A+B`").||
||||||<font face="arial black"> - - Expression-Level Rules - -</font>||
||`EXPR`||`BIN_COND`||Any Expression.||
||`BIN_COND`||`TERNARY`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `?``?` `TERNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Binary Conditional Operator (`thisIfNotNullOrZero ?? thisOtherwise`).||
||`TERNARY`||`COND_OR` <font face="arial black" color="#AAAAFF">[</font> `?` `TERNARY`<font face="arial black" color="#AAAAFF">,,1,,</font> `:` `TERNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font>||(`L-►R`) Ternary Conditional Operator (`condition ? true-value : false-value`).||
||`COND_OR`||`COND_AND`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `|``|` `COND_AND`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Conditional-"OR".||
||`COND_AND`||`BW_OR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `&``&` `BW_OR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Conditional-"AND".||
||`BW_OR`||`BW_XOR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `|` `BW_XOR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Bitwise-"OR".||
||`BW_XOR`||`BW_AND`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `^` `BW_AND`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Bitwise-"XOR".||
||`BW_AND`||`EQUALITY`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `&` `EQUALITY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Bitwise-"AND".||
||`EQUALITY`||`COMPARE`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> <font face="arial black" color="#AAAAFF">(</font> `==` <font face="arial black" color="#AAAAFF">|</font> `!=` <font face="arial black" color="#AAAAFF">)</font> `COMPARE`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Equality ("equal to" `==` ) and Inequality ("not equal to" `!=` ).||
||`COMPARE`||`BITSHIFT`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> <font face="arial black" color="#AAAAFF">(</font> `<` <font face="arial black" color="#AAAAFF">|</font> `>` <font face="arial black" color="#AAAAFF">|</font> `<=` <font face="arial black" color="#AAAAFF">|</font> `>=` <font face="arial black" color="#AAAAFF">)</font> `BITSHIFT`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Less-than, Greater-than, Less-than-equal, Greater-than-equal.||
||`BITSHIFT`||`ADDSUB`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> <font face="arial black" color="#AAAAFF">(</font> `<<` <font face="arial black" color="#AAAAFF">|</font> `>>` <font face="arial black" color="#AAAAFF">|</font> `<<<` <font face="arial black" color="#AAAAFF">|</font> `>>>` <font face="arial black" color="#AAAAFF">)</font> `ADDSUB`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) (Signed) Bit-Shift left and right (`<<` `>>`); Bit-Rotation left and right (`<<<` `>>>`).||
||`ADDSUB`||`MULTDIV`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> <font face="arial black" color="#AAAAFF">(</font> `+` <font face="arial black" color="#AAAAFF">|</font> `-` <font face="arial black" color="#AAAAFF">)</font> `MULTDIV`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Addition and Subtraction.||
||`MULTDIV`||`CAST`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> <font face="arial black" color="#AAAAFF">(</font> `*` <font face="arial black" color="#AAAAFF">|</font> `/` <font face="arial black" color="#AAAAFF">|</font> `%` <font face="arial black" color="#AAAAFF">)</font> `CAST`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Multiply, Division, Modulus (Remainder).||
||`CAST`||`PRE_OP` <font face="arial black" color="#AAAAFF">(</font> `->` <font face="arial black" color="#AAAAFF">(</font> `TYPE`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">|</font> `(` <font face="arial black" color="#AAAAFF">(</font> `TYPE`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `)` <font face="arial black" color="#AAAAFF">)</font> <font face="arial black" color="#AAAAFF">)`*`</font>||(`L-►R`) Type-Cast(s).||
||`UNARY`||_`PRE_OP`_ `VALUE` _`POST_OP`_||Unary operations on a single value (Post-fix operations are applied first).||
||> _`PRE_OP`_||<font face="arial black" color="#AAAAFF">(</font> `+` <font face="arial black" color="#AAAAFF">|</font> `-` <font face="arial black" color="#AAAAFF">|</font> `~` <font face="arial black" color="#AAAAFF">|</font> `!` <font face="arial black" color="#AAAAFF">|</font> `*` <font face="arial black" color="#AAAAFF">|</font> `$` <font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">[</font> `&` <font face="arial black" color="#AAAAFF">|</font> `++` <font face="arial black" color="#AAAAFF">|</font> `--` <font face="arial black" color="#AAAAFF">]</font>||(`L◄-R`) Pre-fix Unary operations.||
||> _`POST_OP`_||<font face="arial black" color="#AAAAFF">(</font> _`INDEX`_ <font face="arial black" color="#AAAAFF">|</font> `.` `P_ID`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">|</font> <font face="arial black" color="#AAAAFF">[</font>`.` `(` `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> `)`<font face="arial black" color="#AAAAFF">]</font> `(` <font face="arial black" color="#AAAAFF">[</font> `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">,</font><font face="arial black" color="#AAAAFF">,</font> <font face="arial black" color="#AAAAFF">]</font> `)` <font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">[</font>`++`<font face="arial black" color="#AAAAFF">|</font>`--`<font face="arial black" color="#AAAAFF">]</font>||(`L-►R`) Post-fix Unary operations.||
||> _`INDEX`_||`[` <font face="arial black" color="#AAAAFF">(</font> `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `]` <font face="arial black" color="#AAAAFF">|</font> `[` <font face="arial black" color="#AAAAFF">[</font> `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font> `..` <font face="arial black" color="#AAAAFF">[</font> `EXPR`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font> `]`||Array Indexing. The "`..`" converts to a tuple (e.g. `a[1..4]` is `(a[1],a[2],a[3])`).||
||||||<font face="arial black"> - - Value-Level Rules - -</font>||
||`VALUE`||`INT` <font face="arial black" color="#AAAAFF">|</font> `CHAR` <font face="arial black" color="#AAAAFF">|</font> `STRING` <font face="arial black" color="#AAAAFF">|</font> `P_ID` <font face="arial black" color="#AAAAFF">|</font> `TUPLE` <font face="arial black" color="#AAAAFF">|</font> `LAMBDA` <font face="arial black" color="#AAAAFF">|</font> `INSTANCE`||A single entity (variable, value, instance literal, anonymous function, inner expression, etc.).||
||`TUPLE`||`(` <font face="arial black" color="#AAAAFF">(</font> `EXPR` <font face="arial black" color="#AAAAFF">|</font> `_` <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `)`||List of one or more expressions ("`(1,2,3)`"). <font color="red">Nested tuples are "unpacked" into this one.</font>||
||`LAMBDA`||<font face="arial black" color="#AAAAFF">[</font> `IDENT`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">|</font> <font face="arial black" color="#AAAAFF">(</font>`P_ID` `.`<font face="arial black" color="#AAAAFF">)`*`</font> `(` <font face="arial black" color="#AAAAFF">(</font> <font face="arial black" color="#AAAAFF">(</font> `IDENT`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">|</font> <font face="arial black" color="#AAAAFF">(</font> `VARDEC` <font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">)</font> `)` _`RETURNS`_ <font face="arial black" color="#AAAAFF">]</font><br><font face="arial black" color="#AAAAFF">(</font> `=>` `COMMAND` <font face="arial black" color="#AAAAFF">|</font> `{` <font face="arial black" color="#AAAAFF">(</font> `STATEMENT` <font face="arial black" color="#AAAAFF">)`*`</font> `}` <font face="arial black" color="#AAAAFF">)</font>||Lamba Expression (anonymous function).||
||`INSTANCE`||<font face="arial black" color="#AAAAFF">[</font> `new` <font face="arial black" color="#AAAAFF">]</font> `TYPE`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> _`V_INIT`_<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">|</font> `{` <font face="arial black" color="#AAAAFF">(</font> `EXPR`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `}` <font face="arial black" color="#AAAAFF">)</font> <font face="arial black" color="#AAAAFF">|</font> `new` <font face="arial black" color="#AAAAFF">[</font> `TYPE`<font face="arial black" color="#AAAAFF">,,2,,</font><br><font face="arial black" color="#AAAAFF">|</font> _`V_INIT`_<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">|</font> <font face="arial black" color="#AAAAFF">[</font>`[` <font face="arial black" color="#AAAAFF">[</font> `EXPR`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">(</font> `,` `EXPR`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">)`*`</font> `]`<font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font>`{` <font face="arial black" color="#AAAAFF">(</font> `EXPR`<font face="arial black" color="#AAAAFF">,,4,,</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `}`<font face="arial black" color="#AAAAFF">]</font>||Literal Instance of a struct, interface, cofunc, or array.||
||`P_ID`||`IDENT` <font face="arial black" color="#AAAAFF">[</font>`<` `TYPE`<font face="arial black" color="#AAAAFF">,</font><font face="arial black" color="#AAAAFF">,</font> `>`<font face="arial black" color="#AAAAFF">]</font>||Parameterized Identifier (with Given Type-Parameters).||
||`P_DT`||`IDENT` <font face="arial black" color="#AAAAFF">[</font>`<` <font face="arial black" color="#AAAAFF">(</font> `IDENT` <font face="arial black" color="#AAAAFF">[</font> `:` `TYPE`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `&` `TYPE`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font> `>`<font face="arial black" color="#AAAAFF">]</font>||Parameterized Data-Type (with constrained Formal Type-Parameters).||
||`IDENT`||<font face="arial black" color="#AAAAFF">(</font> _letter_ <font face="arial black" color="#AAAAFF">|</font> `_` <font face="arial black" color="#AAAAFF">) (</font> _letter_ <font face="arial black" color="#AAAAFF">|</font> _digit_ <font face="arial black" color="#AAAAFF">|</font> `_` <font face="arial black" color="#AAAAFF">)`*`</font>||Identifier (a valid "name" of something, e.g. `x`, `foo2`, `_3D`).||
||`INT`||_digit_<font face="arial black" color="#AAAAFF">+ |</font> `0x`<font face="arial black" color="#AAAAFF">(</font> _digit_ <font face="arial black" color="#AAAAFF">|</font> _A-F_ <font face="arial black" color="#AAAAFF">|</font> _a-f_ <font face="arial black" color="#AAAAFF">)+ |</font> `0b`<font face="arial black" color="#AAAAFF">(</font> `0` <font face="arial black" color="#AAAAFF">|</font> `1` <font face="arial black" color="#AAAAFF">)+</font>||Integer Number in Decimal (`123`), Hexadecimal (`0x7B`), or binary (`0b01111011`) form.||
||`STRING`||<font face="arial black" color="#AAAAFF">[</font> `b` <font face="arial black" color="#AAAAFF">|</font> `i` <font face="arial black" color="#AAAAFF">|</font> `r` <font face="arial black" color="#AAAAFF">]</font> `"` <font face="arial black" color="#AAAAFF">(</font> _`ESC`_ <font face="arial black" color="#AAAAFF">|</font> _any character but_ `"` _or_ `\` _or_ `ENTER` <font face="arial black" color="#AAAAFF">)</font> `"`||String Literal (e.g. `"null terminated"`, `b"byte prefixed"`, `i"int prefixed"`, `r"raw"`)||
||`CHAR`||`'` <font face="arial black" color="#AAAAFF">(</font> _`ESC`_ <font face="arial black" color="#AAAAFF">|</font> _any character but_ `'` _or_ `\` _or_ `ENTER` <font face="arial black" color="#AAAAFF">)</font> `'`||Character Literal (e.g. `'A'`, `'\n'`, `' '`).||
||> _`ESC`_||`\n` <font face="arial black" color="#AAAAFF">|</font> `\r` <font face="arial black" color="#AAAAFF">|</font> `\t` <font face="arial black" color="#AAAAFF">|</font> `\0` <font face="arial black" color="#AAAAFF">|</font> `\'` <font face="arial black" color="#AAAAFF">|</font> `\"` <font face="arial black" color="#AAAAFF">|</font> `\\`||Escape Characters (Line-Feed, Carriage-Return, Tab, Null, `'`, `"`, `\`).||

<br>
----
= Syntax Tree Classes =
----
<br>

The following classes will be used to build a [http://en.wikipedia.org/wiki/Abstract_syntax_tree syntax tree] from source code parsed by the compiler.

==== Conventions Used: ====

 * Syntax:` ClassName { `*`Datatype`*` Member1; `*`DataType`*` Member2; }`
 * Sub-classes are hierarchically nested under their parent-classes.
 * Abstract (non-instantiable) classes are in `<`angle brackets`>`.
 * Arrays are denoted by `[`square brackets`]` after the datatype.
 * Comments (notes) are listed in green after a double-slash: <font color="green">`// This is a comment`</font>.

==== The Classes: ====

 * `Type { `*`Expression`*`[] dims; `*`Bool`*` static, const, volatile, ref; `*`BaseType`*` base; }`
 * `<BaseType> { }`
   * `FuncPtr { `*`Entity`*` receiver; `*`Variable`*`[] args; `*`Type`*`[] returns; }`
   * `Entity { `*`Token`*` name; `*`Type`*`[] params; `*`Entity`*` next; }`
 * `Using { `*`Token`*` alias; `*`Entity`*` entity; }`
 * `Context { `*`Namespace`*` namespace; `*`Using`*`[] usings; }`
 * `TParam { `*`Token`*` name; `*`Entity`*`[] constraints; }`
 * `Namespace { `*`TParam`*`[] params; `*`Namespace`*` parent; `*`Namespace`*`[] children; `*`Global`*`[] contents; }`
 * `<Global> { `*`Context`*` context; `*`Token`*` name; }`
   * `Init { `*`Block`*` code; }`
   * `Enum { `*`Token`*`[] values; }`
   * `SWVar { `*`Token`*`[] values; }`
   * `TypeDef { `*`Type`*` type; `*`Bool`*` isNew; }`
   * `Iface { `*`TParam`*`[] params; `*`Member`*`[] members; }`
   * `Struct { `*`TParam`*`[] params; `*`Member`*`[] members; `*`Func`*`[] constructors; `*`Func`*` destructor; }`
   * `<Member> { }`
     * `Variable { `*`Type`*` type; `*`Bool`*` ipret; `*`Expression`*` alias; `*`Expression`*` init; }`
       *  <font color="green">`// Type can be CONST for constants`</font>
     * `Func { `*`TParam`*`[] params; `*`FuncPtr`*` signature; `*`Block`*` code; `*`Bool`*` ipret; }`
       * `Cofunc { STRUCT struct; } `<font color="green">`// "@foo" args stored as if "Type foo@foo"`</font>
 * `Block { `*`Statement`*`[] code; `*`Bool`*` braces; }`
 * `<Statement> { }`
   * `Label { `*`Token`*` name; }`
   * `<Construct> { `*`Bool`*` ipret; `*`Block`*` code; }`
     * `ForEach { `*`Variable`*`[] vars; `*`Bool`*` def; `*`Expression`*` start,end,inc; }`
     * `Conditional { `*`Token`*` kind; `*`Expression`*` cond; }`
       *  <font color="green">`// kinds: if, switch, while, until, do, for`</font>
       * `If { `*`Block`*` elseCode; }`
       * `Do { `*`Token`*` logic; int condPos; }`
       * `For { `*`Command`*` init; `*`Command`*` step; }`
   * `<Command> { }`
     * `VarDec { `*`Type`*` type; `*`Variable`*`[] vars; }`
     * `Instruction { `*`Token`*` kind; `*`Expression`*` value; }`
       *  <font color="green">`// kinds: branch, delete, =>while/until, operator (=,+=,++,etc.)`</font>
     * `Assembly { `*`Expression`*`[] values; }`
 * `<Expression> { `*`Bool`*` ipret; }`
   * `Operation { `*`Token`*` kind; `*`Expression`*` left, right; }`
     * `Ternary { `*`Expression`*` condition; }`
   * `Lambda { `*`FuncPtr`*` signature; `*`Block`*` code; }`
   * `Call { `*`Bool`*` isNew; `*`Expression`*`[] args; `*`Expression`*`[] inits; }`
     *  <font color="green">`// function/constructor call`</font>
   * `Cast { `*`Expression`*` left; `*`Type`*`[] `*`Type`*`s; }`
   * `Value { `*`Token`*` value; }`

<br>
----
= Example Walkthrough =
----
<br>

Each grammar rule corresponds to a portion of code (within the compiler)
responsible for parsing (reading) designated portions of the language syntax. The compiler will follow these rules (or rather, the code that these rules represent) in a [http://en.wikipedia.org/wiki/Recursive_descent_parser recursive decent] pattern in order to convert source code into an [http://en.wikipedia.org/wiki/Abstract_syntax_tree organized structure] for further analysis. As an example, we can use the grammar to trace out how the compiler would parse the following snippet of code:

`uint x = a + b * c;`

(Oops! This flow needs to be updated to match recent changes in the grammar. I will do so a bit later).

 * Since this small snippet of code can actually represent an entire program, we can start at "the top" with the "`SOURCE`" rule. Since this code represents a variable declaration, we replace "`SOURCE`" with the "`VARDEC` `;`" option, and resolve the "`VARDEC`" rule similarly:
   * "`VARDEC`" is replaced with the option that matches our code ("_`MODS`_ `TYPE` <font face="arial black" color="#AAAAFF">(</font> `LAMBDA`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">[</font> `@` `LAMBDA`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font> `=` `LAMBDA`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font>").
     * "_`MODS`_" resolves to "<font face="arial black" color="#AAAAFF">(</font> `static` <font face="arial black" color="#AAAAFF">|</font> `const` <font face="arial black" color="#AAAAFF">|</font> `volatile` <font face="arial black" color="#AAAAFF">)`*`</font>". This is repeated "zero times", since none of these modifiers are used.
     * "`TYPE`" resolves to "`EXPR`", which resolves directly to "`ASSIGN`".
       * "`ASSIGN`" resolves to "`LAMBDA` <font face="arial black" color="#AAAAFF">[</font> _`AOP`_ `ASSIGN` <font face="arial black" color="#AAAAFF">]</font>".
         * "`LAMBDA`" is replaced with its first option ("`T_CAST` <font face="arial black" color="#AAAAFF">[</font> `=>` `ASSIGN` <font face="arial black" color="#AAAAFF">]</font>"), since our code does not start with "`( )`".
           * "`T_CAST`" resolves to "`TERNARY`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">(</font> `:` `TERNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>", which resolves to "`OR` <font face="arial black" color="#AAAAFF">[</font> `?` `TERNARY`<font face="arial black" color="#AAAAFF">,,1,,</font> `:` `TERNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font>", *. . .*<br>This continues from "`T_CAST`" down through "`PRIMARY`", dropping all optional items (<font face="arial black" color="#AAAAFF">[` `]</font> or <font face="arial black" color="#AAAAFF">(` `)`*`</font>),<br>until ultimately "`PRIMARY`" resolves to just "`VALUE`".
             * "`VALUE`" is replaced with "`IDENT`", which is a stand-in for any identifier.
               * "`IDENT`" is replaced with the identifier "`uint`" to match our example.
                 * <font color="blue">Stored as *`Value{uint}`*</font>
             * "`VALUE`" has now become "`uint`".
           * "`T_CAST`" has become "`TERNARY`" has become "`OR`" ... has become "`uint`".
             * The <font color="#C00">additional semantics</font> (additional requirements) of "`T_CAST`" are not applicable here, since "`:`" was not used (the optional "<font face="arial black" color="#AAAAFF">(</font> `:` `TERNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>" portion was "dropped").
           * The optional "<font face="arial black" color="#AAAAFF">[</font> `=>` `ASSIGN` <font face="arial black" color="#AAAAFF">]</font>" portion is dropped, since it is not used.
         * "`LAMBDA`" has now become "`uint`".
           * The <font color="#C00">additional semantics</font> of "`LAMBDA`" are not applicable ("`=>`" not used).
         * The optional "<font face="arial black" color="#AAAAFF">[</font> _`AOP`_ `ASSIGN` <font face="arial black" color="#AAAAFF">]</font>" is not used here.
       * "`ASSIGN`" (and thus "`EXPR`") has now become "`uint`".
     * "`TYPE`" has now become "`uint`".
       * <font color="blue">Stored as *`Name{uint}`* (with "`uint`" pulled out of the *Value*)</font>
       * The <font color="#C00">additional semantics</font> of "`TYPE`" require that any "`[]`" and "`*`" operations must come "first", followed by any number of "`IDENT.`" operations, and have either an `IDENT`, _`FUNCP`_ (function pointer type), or _`SW_VAR`_ (switch-variable type) at the "end" (in other words, we must have something that "looks" like a valid datatype). These requirements are met, since this instance of "`TYPE`" has now become just "`uint`", so we continue (i.e. there are no "errors").
     * The "<font face="arial black" color="#AAAAFF">(</font> `LAMBDA`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">[</font> `@` `LAMBDA`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font> `=` `LAMBDA`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font>" portion of the "`VARDEC`" rule represents a comma-separated-list ("<font face="arial black" color="#AAAAFF">(` `),</font>") of variables being declared. Since our code has only one variable declaration, this portion is only repeated once (and thus, there are no commas "between items").
       * "`LAMBDA`<font face="arial black" color="#AAAAFF">,,1,,</font>" resolves to "`T_CAST` <font face="arial black" color="#AAAAFF">[</font> `=>` `ASSIGN` <font face="arial black" color="#AAAAFF">]</font>" (rather than "`(` `)` `=>` `ASSIGN`", since our code does not have parentheses).
         * "`T_CAST`" _eventually_ resolves down to "`IDENT`" as before.
             * This time, the matching identifier is "`x`", so _this_ "`IDENT`" has now become "`x`".
               * <font color="blue">Stored as *`Value{x}`*</font>
         * "`T_CAST`" has now become "`x`" (and <font color="#C00">additional semantics</font> do not apply).
         * The optional "<font face="arial black" color="#AAAAFF">[</font> `=>` `ASSIGN` <font face="arial black" color="#AAAAFF">]</font>" is removed, since it is not used.
       * The optional "<font face="arial black" color="#AAAAFF">[</font> `@` `LAMBDA`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font>" is removed, since it is not used.
       * The optional "<font face="arial black" color="#AAAAFF">[</font> `=` `LAMBDA`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font>" *is* used.
         * The "`=`" from the rule matches the "`=`" from our example code.
         * "`LAMBDA`<font face="arial black" color="#AAAAFF">,,3,,</font>" resolves as before (dropping all the unused optional "<font face="arial black" color="#AAAAFF">[` `]</font>" "<font face="arial black" color="#AAAAFF">(` `)`*`</font>" portions), but _this_ time only down to "`ADDSUB`", since it has optional portions which *are* used (the "`+`" operator):
           * "`ADDSUB`" resolves to "`MULTDIV`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">( (</font> `+` <font face="arial black" color="#AAAAFF">|</font> `-` <font face="arial black" color="#AAAAFF">)</font> `MULTDIV`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>".
             * "`MULTDIV`<font face="arial black" color="#AAAAFF">,,1,,</font>" _eventually_ resolves down to "`IDENT`", which in turn becomes "`a`".
               * <font color="blue">Stored as *`Value{a}`*</font>
             * The "<font face="arial black" color="#AAAAFF">( (</font> `+` <font face="arial black" color="#AAAAFF">|</font> `-` <font face="arial black" color="#AAAAFF">)</font> `MULTDIV`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>" portion is repeated *one time*, as follows:
             * The first option of "<font face="arial black" color="#AAAAFF">(</font> `+` <font face="arial black" color="#AAAAFF">|</font> `-` <font face="arial black" color="#AAAAFF">)</font>" is chosen to match the "`+`" used in our code.
             * "`MULTDIV`<font face="arial black" color="#AAAAFF">,,2,,</font>" resolves down to "`UNARY`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">( (</font> `*` <font face="arial black" color="#AAAAFF">|</font> `/` <font face="arial black" color="#AAAAFF">|</font> `%` <font face="arial black" color="#AAAAFF">)</font> `UNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>".
                 * "`UNARY`<font face="arial black" color="#AAAAFF">,,1,,</font>" _eventually_ resolves down to "`IDENT`", which in turn becomes "`b`".
                   * <font color="blue">Stored as *`Value{b}`*</font>
                 * The "<font face="arial black" color="#AAAAFF">( (</font> `*` <font face="arial black" color="#AAAAFF">|</font> `/` <font face="arial black" color="#AAAAFF">|</font> `%` <font face="arial black" color="#AAAAFF">)</font> `UNARY`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">)`*`</font>" portion is repeated *once*, as follows:
                 * The first option of "<font face="arial black" color="#AAAAFF">(</font> `*` <font face="arial black" color="#AAAAFF">|</font> `/` <font face="arial black" color="#AAAAFF">)</font>" is chosen to match the "`*`" used in our code.
                 * "`UNARY`<font face="arial black" color="#AAAAFF">,,2,,</font>" _eventually_ resolves to "`IDENT`", which becomes "`c`".
                   * <font color="blue">Stored as *`Value{c}`*</font>
             * "`MULTDIV`<font face="arial black" color="#AAAAFF">,,2,,</font>" has now become "`b * c`".
               * <font color="blue">Stored as *`Operation{*, Value{b}, Value{c}}`*</font>
           * "`ADDSUB`" has now become "`a + b * c`".
             * <font color="blue">Stored as *`Operation{+, Value{a}, Operation{*,...}}`*</font>
         * "`LAMBDA`<font face="arial black" color="#AAAAFF">,,3,,</font>" has now become "`a + b * c`".
       * The "<font face="arial black" color="#AAAAFF">[</font> `=` `LAMBDA`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font>" portion has become "`= a + b * c`".
     * The "<font face="arial black" color="#AAAAFF">(</font> `LAMBDA`<font face="arial black" color="#AAAAFF">,,1,,</font> <font face="arial black" color="#AAAAFF">[</font> `@` `LAMBDA`<font face="arial black" color="#AAAAFF">,,2,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">[</font> `=` `LAMBDA`<font face="arial black" color="#AAAAFF">,,3,,</font> <font face="arial black" color="#AAAAFF">]</font> <font face="arial black" color="#AAAAFF">),</font><font face="arial black" color="#AAAAFF">,</font>" portion has now become "`x = a + b * c`".
   * "`VARDEC`" has now become "`uint x = a + b * c`".
     * <font color="blue">Stored as *`VarDec{Name{uint}, x, Operation{+, Value{a}, Operation{*,...}}}`*</font>
     * The <font color="#C00">additional semantics</font> are met (including the allowance of the assignment on the "outside").
   * The "`;`" (semicolon) matches the one from our example code.
 * "`SOURCE`" has now become "`uint x = a + b * c;`", which matches the original code before parsing.
   * <font color="blue">The *`VarDec`* is replaced with *`Variable{x, Name{uint}, Operation{+,...}}`*</font>
 * <font color="blue">The entire source is stored as *`Namespace{(none), Variable{x,...}}`*</font>

*Note:* Rather than starting with code and filtering it through rules (as the compiler would), this same process can be used to build any (syntactically accurate) Antelope program from scratch!

The <font color="blue">blue highlights</font> show how the compiler uses the classes (listed previously on this page) to store the results of each step in the parsing. Notice that not _all_ steps result in such a construction: Most of the rules will transparently pass a class entry from a lower rule to a higher rule without making any changes. However, each rule provides an _opportunity_ for a different kind of operation to be given. This allows different kinds of operations to be applied in a predefined order (e.g. multiplication before addition, as you can see where the "`*`" operation was stored within the "`+`" operation, which is not the same order that they _appear_ from left to right).

Sometimes the results are switched from one class to another as they are parsed. This allows some things to be stored in a way that matches items at one level, which then turn out to be intended for another use at a higher level. For example, something like "`*foo.bar`" would at first be represented as a dereference of some "bar" entry in some "foo" structure; but then a higher context would determine that it is actually being used as a datatype (a pointer to some "bar" type from some "foo" namespace) as in "`*foo.bar x = y`". Such changes can be seen in the above example where "`uint`" starts as a *`Value`* but comes out as a *`Type`*. Likewise, since variable declarations at the namespace-level really only serve to create namespace-level variables (rather than creating and initializing them as an executable _statement_), the resulting *`VarDec`* (Variable declaration) is discarded and replaced with a *`Variable`* containing the relevant information, which is in turn stored in a *`Namespace`* entry.

<br>
----
= Order of Operations =
----
<br>

Operators are evaluated (bound) in order from top (`1`) to bottom (`17`). Lambdas bind stronger on the left ( <font color="#BBBBBB">`_`</font>`=>` ) than on the right ( `=>`<font color="#BBBBBB">`_`</font> ).

 # <font color="#BBBBBB">`(L─►R)`</font>` `<font color="#BBBBBB">`_`</font>`.member `<font color="#BBBBBB">`_`</font>`(call) `<font color="#BBBBBB">`_`</font>`[index] `<font color="#BBBBBB">`_`</font>`++ `<font color="#BBBBBB">`_`</font>`-- `<font color="#BBBBBB">`_`</font>`=>`
 # <font color="#BBBBBB">`(L◄─R)`</font>` +`<font color="#BBBBBB">`_`</font>` -`<font color="#BBBBBB">`_`</font>` !`<font color="#BBBBBB">`_`</font>` ~`<font color="#BBBBBB">`_`</font>` *`<font color="#BBBBBB">`_`</font>` $`<font color="#BBBBBB">`_`</font>` &`<font color="#BBBBBB">`_`</font>` ++`<font color="#BBBBBB">`_`</font>` --`<font color="#BBBBBB">`_`</font>
 # <font color="#BBBBBB">`(L─►R)`</font>` `<font color="#BBBBBB">`_`</font>` -> `<font color="#BBBBBB">`TYPE`</font>
 # <font color="#BBBBBB">`(L─►R)`</font>` * / %`
 # <font color="#BBBBBB">`(L―►R)`</font>` + -`
 # <font color="#BBBBBB">`(L─►R)`</font>` << >> <<< >>>`
 # <font color="#BBBBBB">`(L─►R)`</font>` < > <= >=`
 # <font color="#BBBBBB">`(L─►R)`</font>` == !=`
 # <font color="#BBBBBB">`(L─►R)`</font>` &`
 # <font color="#BBBBBB">`(L─►R)`</font>` ^`
 # <font color="#BBBBBB">`(L─►R)`</font>` |`
 # <font color="#BBBBBB">`(L─►R)`</font>` &&`
 # <font color="#BBBBBB">`(L─►R)`</font>` ||`
 # <font color="#BBBBBB">`(L─►R)`</font>` `<font color="#BBBBBB">`TEST`</font>` ? `<font color="#BBBBBB">`TRUE`</font>` : `<font color="#BBBBBB">`FALSE`</font>
 # <font color="#BBBBBB">`(L─►R)`</font>` `<font color="#BBBBBB">`NONZERO`</font>` ?? `<font color="#BBBBBB">`OTHERWISE`</font>
 # <font color="#BBBBBB">`(L◄─R)`</font>` = *= /= %= += -= <<= >>= <<<= >>>= &= ^= |= =>`<font color="#BBBBBB">`_`</font>
 # <font color="#BBBBBB">`(L─►R)`</font>` ,`